<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Falling & Breaking Text on Scroll</title>
<style>
  :root{
    --fall-duration: 1200ms;     /* base duration for fall animation */
    --stagger: 30ms;             /* time between each letter's delay */
    --max-rotate: 45deg;         /* max rotation applied to pieces */
    --max-x: 60px;               /* max horizontal drift */
    --max-y: 400px;              /* max vertical fall distance */
    --blur-end: 1.5px;           /* blur at end */
  }

  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    line-height: 1.4;
    padding: 80px 20px;
    background: #fafafa;
    color: #111;
  }

  /* container and spacer to allow scrolling demo */
  .spacer { height: 70vh; }
  .container {
    max-width: 760px;
    margin: 0 auto;
  }

  /* the element that will break apart */
  .break-text {
    position: relative;
    font-size: 32px;
    font-weight: 600;
    cursor: default;
    overflow: visible; /* needed since letters become absolute */
  }

  /* inline wrapper for words */
  .word {
    display: inline-block;
    white-space: nowrap;
    margin-right: 0.45ch;
    position: relative; /* anchor for letters */
  }

  /* letter baseline style */
  .letter {
    display: inline-block;
    position: relative; /* initially static to measure */
    transform-origin: center;
    transition: transform 260ms ease, opacity 260ms ease;
    will-change: transform, opacity, filter;
  }

  /* when activated, move letters to absolute so they can fall independently */
  .breaking .letter {
    position: absolute;
    top: 0;
    left: 0;
  }

  /* the animation applied to each piece (uses CSS variables set inline by JS) */
  .breaking .letter.fall {
    animation-name: fall-and-spin;
    animation-duration: var(--d, 1000ms);
    animation-delay: var(--delay, 0ms);
    animation-fill-mode: forwards;
    animation-timing-function: cubic-bezier(.12,.78,.35,1);
  }

  @keyframes fall-and-spin {
    0% {
      transform: translate(0,0) rotate(0deg) scale(1);
      opacity: 1;
      filter: blur(0px);
    }
    60% {
      /* small upward overshoot avoiding instant drop */
      transform: translate(var(--sx, 0px), calc(var(--sy, 0px) * 0.4)) rotate(calc(var(--r) * 0.4));
      opacity: 1;
    }
    100% {
      transform: translate(var(--tx, 0px), var(--ty, 400px)) rotate(var(--r));
      opacity: 0;
      filter: blur(var(--blur, 0px));
    }
  }
a {
  text-decoration: none;
  color: #777;
  font-weight: bold;
}
  /* accessibility: respect reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .breaking .letter.fall {
      animation: none !important;
      transform: translate(0,0) rotate(0) !important;
      opacity: 1 !important;
    }
  }


</style>
</head>
<body>

<div class="spacer"></div>

<div class="container">
  <!-- Put your text inside this element -->
  <div id="myText" class="break-text">
    I walked through Manhattan, staring at my phone, when I noticed the manhole covers beneath my feet. I imagined stepping on one that wasn’t round and tumbling into the hidden tunnels below—rats scurrying, steam hissing, and pipes humming all around me. It made me realize how much of the city’s secret life exists just out of sight.
  
</div>
<a href="page.html">Climb Back</a>
<div class="spacer"></div>

<script>
/*
  Script overview:
  1. Split the text into words and letters, wrapping them in .word and .letter spans.
  2. On scroll (IntersectionObserver), when the element enters viewport, mark container as .breaking.
  3. Convert letters to absolutely positioned pieces with randomized animation variables:
     --delay, --tx, --ty, --r, --d, --blur
  4. Add class .fall to start animation.
*/

(function(){
  const el = document.getElementById('myText');
  if(!el) return;

  // 1. split into words/letters
  const text = el.textContent.trim();
  const words = text.split(/\s+/);
  el.innerHTML = ''; // clear

  words.forEach((w,i) => {
    const wordWrap = document.createElement('span');
    wordWrap.className = 'word';
    // preserve spaces by adding space after each word later in layout via margin-right
    for (let j = 0; j < w.length; j++){
      const ch = w[j];
      const span = document.createElement('span');
      span.className = 'letter';
      span.textContent = ch;
      wordWrap.appendChild(span);
    }
    el.appendChild(wordWrap);
  });

  // small function to get bounding rects for positioning
  function placeLettersAbsolute(container){
    // compute offsets for each letter relative to container
    const containerRect = container.getBoundingClientRect();
    const words = Array.from(container.querySelectorAll('.word'));

    words.forEach(word => {
      // for each letter get its position then move to absolute positioning
      const letters = Array.from(word.querySelectorAll('.letter'));
      letters.forEach(letter => {
        const r = letter.getBoundingClientRect();
        // calculate offsets relative to container
        const offsetLeft = r.left - containerRect.left;
        const offsetTop = r.top - containerRect.top;
        // set inline position style on the letter so when switching to absolute
        letter.style.left = offsetLeft + 'px';
        letter.style.top = offsetTop + 'px';
      });
    });

    // set container height to preserve layout (so page doesn't jump)
    container.style.minHeight = containerRect.height + 'px';
  }

  // 2. IntersectionObserver to trigger when we see the text
  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // before switching to .breaking, compute positions
        placeLettersAbsolute(el);
        el.classList.add('breaking');
        // kick off the piece animations
        startFallAnimation(el);
        obs.unobserve(entry.target); // only run once; remove if you want repeatable
      }
    });
  }, { threshold: 0.35 });

  observer.observe(el);

  // 3. function to set random CSS vars and add fall class
  function startFallAnimation(container){
    const letters = Array.from(container.querySelectorAll('.letter'));
    letters.forEach((letter, idx) => {
      // randomize x drift (-maxX..maxX), y fall (up to maxY), rotation (-maxR..maxR)
      const maxX = 60;   // px
      const maxY = 420;  // px
      const maxR = 45;   // deg

      const driftX = (Math.random()*2 - 1) * maxX; // px
      const fallY = maxY + Math.random()*80;       // px
      const rot = (Math.random()*2 - 1) * maxR;    // deg

      // slight start offset for 'scatter' effect
      const startX = (Math.random()*2 - 1) * 10;
      const startY = (Math.random()*-1) * 10; // some letters jump up slightly

      // duration and delay
      const baseDuration = 1000 + Math.random()*700; // ms
      const delay = idx * 28 + Math.random()*140;   // staggered

      // set CSS variables
      letter.style.setProperty('--tx', driftX + 'px');
      letter.style.setProperty('--ty', fallY + 'px');
      letter.style.setProperty('--r', rot + 'deg');
      letter.style.setProperty('--sx', startX + 'px');
      letter.style.setProperty('--sy', startY + 'px');
      letter.style.setProperty('--d', baseDuration + 'ms');
      // blur grows slightly with fall distance
      letter.style.setProperty('--blur', (Math.abs(driftX)/60 * 1.2 + 0.4) + 'px');
      letter.style.setProperty('--delay', delay + 'ms');

      // trigger with tiny timeout to allow layout / styles to settle
      setTimeout(() => {
        letter.classList.add('fall');
      }, 20);
    });
  }

  // If window resizes before animation, make sure to recompute positions (optional)
  window.addEventListener('resize', () => {
    // only recompute if not yet .breaking; once breaking, pieces are absolute and animated
    if (!el.classList.contains('breaking')) {
      placeLettersAbsolute(el);
    }
  });

})();
</script>
</body>
</html>
